{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-garden","title":"Welcome to Garden","text":""},{"location":"dsa/","title":"Index","text":"<p>DSA structure and algorithms notes</p> <p> </p>"},{"location":"dsa/#topics","title":"Topics","text":"<ul> <li> Graph</li> <li> Trees</li> <li> DP</li> </ul>"},{"location":"dsa/array/","title":"Index","text":"<p>Arrays</p> Questions Status Find the Union #done\u2705 Find the number that appears once and others twice #done\u2705 Longest subarray with given sum K #done\u2705 2 Sum problem #done\u2705 Sort an array or 0's 1's 2's #todo\ud83d\udd8b\ufe0f Majority Element #todo\ud83d\udd8b\ufe0f Kadanes Algorithm #todo\ud83d\udd8b\ufe0f Print subarray with maximum subarray sum #todo\ud83d\udd8b\ufe0f Stock Buy and Sell #todo\ud83d\udd8b\ufe0f Rearrange the array in alternating positive and negative items #todo\ud83d\udd8b\ufe0f Next Permutation #todo\ud83d\udd8b\ufe0f Leaders in an array problem #todo\ud83d\udd8b\ufe0f Longest Consecutive Sequence in an Array #todo\ud83d\udd8b\ufe0f Set Matrix Zeroes #todo\ud83d\udd8b\ufe0f Rotate Matrix by 90degrees #todo\ud83d\udd8b\ufe0f Print the matrix in spiral manner #todo\ud83d\udd8b\ufe0f Count subarrays with give sum #todo\ud83d\udd8b\ufe0f Questions Status Pascals Triangle #todo\ud83d\udd8b\ufe0f 3Sum Problem #todo\ud83d\udd8b\ufe0f 4Sum Problem #todo\ud83d\udd8b\ufe0f Largest Subarray with zero sum #todo\ud83d\udd8b\ufe0f Count number of subarray with given xor K #todo\ud83d\udd8b\ufe0f Merge Overlapping Intervals #todo\ud83d\udd8b\ufe0f Merge two arrays without extra space #todo\ud83d\udd8b\ufe0f Finding the repeating and missing number #todo\ud83d\udd8b\ufe0f Count Inversions #todo\ud83d\udd8b\ufe0f Reverse Pairs #todo\ud83d\udd8b\ufe0f Maximum Product Subarray #todo\ud83d\udd8b\ufe0f"},{"location":"dsa/array/2-sum-problem/","title":"2 sum problem","text":"<p>Given an array of integers\u00a0<code>nums</code>\u00a0and an integer\u00a0<code>target</code>, return\u00a0indices of the two numbers such that they add up to\u00a0<code>target</code>.</p> <pre><code>def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n    pre = {}\n    for i in range(len(nums)):\n        num = nums[i]\n        if target - num in pre:\n            return [pre[target - num], i]\n        if num not in pre:\n            pre[num] = i\n    return\n</code></pre>"},{"location":"dsa/array/2-sum-problem/#questions","title":"Questions","text":"<ol> <li>https://leetcode.com/problems/two-sum/</li> </ol>"},{"location":"dsa/array/find-the-number-that-appears-once-and-others-twice/","title":"Find the number that appears once and others twice","text":"<p>Given a\u00a0non-empty\u00a0array of integers\u00a0<code>nums</code>, every element appears\u00a0twice\u00a0except for one. Find that single one.</p> <pre><code>def singleNumber(self, nums: List[int]) -&gt; int:\n    ans = 0\n    for num in nums:\n        ans ^= num\n    return ans\n</code></pre> <p>Note</p> <p>Xor of any two num gives the difference of bit as 1 and same bit as 0 \\(x \\oplus x = 0\\) and \\(x \\oplus 0 = x\\)</p>"},{"location":"dsa/array/find-the-union/","title":"Find the union","text":"<p>Given two\u00a0sorted\u00a0arrays\u00a0\\(a\\)\u00a0and\u00a0\\(b\\), where each array may contain\u00a0duplicate\u00a0elements , the task is to return the elements in the\u00a0union\u00a0of the two arrays in\u00a0sorted\u00a0order.</p> <pre><code>def findUnion(self,a,b):\n    x, y = 0, 0\n    ans = []\n    while x &lt; len(a) and y &lt; len(b):\n        if a[x] &lt; b[y]:\n            ans.append(a[x])\n            x += 1\n            while x &lt; len(a) and a[x] == a[x - 1]: # skip the dupes\n                x += 1\n        elif b[y] &lt; a[x]:\n            ans.append(b[y])\n            y += 1\n            while y &lt; len(b) and b[y] == b[y - 1]:\n                y += 1\n        else:\n            x += 1\n    while x &lt; len(a):\n        ans.append(a[x])\n        x += 1\n        while x &lt; len(a) and a[x] == a[x - 1]:\n            x += 1\n    while y &lt; len(b):\n        ans.append(b[y])\n        y += 1\n        while y &lt; len(b) and b[y] == b[y - 1]:\n            y += 1\n    return ans\n</code></pre>"},{"location":"dsa/array/longest-subarray-with-given-sum-k/","title":"Longest subarray with given sum k","text":"<p>Given an array\u00a0<code>arr[]</code>\u00a0containing integers and an integer\u00a0<code>k</code>, your task is to find the length of the longest subarray where the sum of its elements is equal to the given value\u00a0<code>k</code>. If there is no subarray with sum equal to\u00a0<code>k</code>, return\u00a0<code>0</code>.</p> <pre><code>def longestSubarray(self, arr, k):  \n    curr = 0\n    prefix = { 0 : -1 }\n    ans = 0\n    for i in range(len(arr)):\n        curr += arr[i]\n        if curr - k in prefix: # check if prefix available\n            ans = max(ans, i - prefix[curr - k])\n        if curr not in prefix:\n            prefix[curr] = i  # store prefix\n    return ans\n</code></pre> <p>This is based on prefix sum. ==One can represent a subarray as difference of 2 prefix subarrays==. We store the prefix sum and check for it in the loop</p>"},{"location":"dsa/array/longest-subarray-with-given-sum-k/#questions","title":"Questions","text":"<ol> <li>https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=longest-sub-array-with-sum-k</li> </ol>"},{"location":"dsa/array/majority-element/","title":"Majority element","text":"<p>https://leetcode.com/problems/majority-element-ii/</p>"},{"location":"dsa/dp/","title":"Dynamic Programming","text":"<p>Dynamic Programming  \ud83d\udcc8</p>"},{"location":"dsa/dp/#1-d-dp","title":"1-D DP","text":"Topic Status Climbing Stairs #done\u2705 Frog Jump #done\u2705 Frog Jump with K distances #done\u2705 Maximum sum of non-adjacent elements #done\u2705 House Robber #done\u2705 ###### 2D/3D DP Topic Status -------------------------------- -------- Ninja Training #todo\ud83d\udd8b\ufe0f Grid Unique Paths #todo\ud83d\udd8b\ufe0f Minimum Path Sum #todo\ud83d\udd8b\ufe0f Minimum Path Sum Triangular Grid #todo\ud83d\udd8b\ufe0f Min Max Falling Path Sum #todo\ud83d\udd8b\ufe0f Ninja and his friends #todo\ud83d\udd8b\ufe0f"},{"location":"dsa/dp/climbing-stairs/","title":"Climbing stairs","text":"<p>You are climbing a staircase. It takes\u00a0<code>n</code>\u00a0steps to reach the top.</p> <p>Each time you can either climb\u00a0<code>1</code>\u00a0or\u00a0<code>2</code>\u00a0steps. In how many distinct ways can you climb to the top?</p>"},{"location":"dsa/dp/climbing-stairs/#top-down-approach","title":"Top Down Approach","text":"<p>We use recursion and keep breaking the problem in smaller cases until we reach the base case and then we calculate the answer bottom up, in different questions the way we calculate answer differs <pre><code>class Solution:\n    def climbStairs(self, n: int) -&gt; int:\n        dp = [-1 for _ in range(n + 1)]\n        def climb(n):\n            if dp[n] != -1:\n                return dp[n]\n            if n &lt; 0:\n                return 0\n            if n == 0:\n                return 1\n            dp[n] = climb(n - 1) + climb(n - 2)\n            return dp[n]\n        return climb(n)\n</code></pre></p>"},{"location":"dsa/dp/climbing-stairs/#bottom-down-approach","title":"Bottom Down Approach","text":"<p>We use top down approach where we declare the base case and solve for every possible state <pre><code>class Solution:\n    def climbStairs(self, n: int) -&gt; int:\n        dp = [0 for _ in range(n + 1)]\n        dp[0] = 1\n        for step in range(n + 1):\n            if step - 1 &gt;= 0:\n                dp[step] += dp[step - 1]\n            if step - 2 &gt;= 0:\n                dp[step] += dp[step - 2]\n        return dp[n]\n</code></pre></p>"},{"location":"dsa/dp/frog-jump-with-k-distances/","title":"Frog jump with k distances","text":"<p>There is an array\u00a0\\(arr\\)\u00a0of heights of stone and Geek is standing at the first stone and can jump to one of the following: Stone i+1, i+2, ... i+k stone, where k is the maximum number of steps that can be jumped\u00a0and cost will be \\(|h_i-h_j|\\) is incurred, where j is the stone to land on. Find the minimum possible total cost incurred before the Geek reaches the last stone.</p>"},{"location":"dsa/dp/frog-jump-with-k-distances/#top-down-approach","title":"Top Down Approach","text":"<pre><code>def minimizeCost(self, k, arr):\n    dp = [-1 for _ in range(len(arr))]\n    def min_jump(stone):\n        if dp[stone] != -1:\n            return dp[stone]\n        if stone &gt;= len(arr):\n            return math.inf\n        if stone == len(arr) - 1:\n            return 0\n\n        min_step = math.inf\n        for i in range(1, k + 1):\n            if stone + i &lt; len(arr):\n                min_step = min(min_step, abs(arr[stone] - arr[stone + i]) + min_jump(stone + i))\n        dp[stone] = min_step\n        return min_step\n    return min_jump(0)\n</code></pre>"},{"location":"dsa/dp/frog-jump-with-k-distances/#top-down-approach_1","title":"Top Down Approach","text":"<pre><code>def minimizeCost(self, k, arr):\n    dp = [math.inf for i in range(len(arr))]\n    if k &gt;= len(arr):\n        return abs(arr[0] - arr[-1])\n    for i in range(k):\n        dp[i] = abs(arr[0] - arr[i])\n    for step in range(k, len(arr)):\n        for i in range(1, k + 1):\n            dp[step] = min(dp[step], dp[step - i] + abs(arr[step] - arr[step - i]))\n    return dp[len(arr) - 1]\n</code></pre>"},{"location":"dsa/dp/frog-jump/","title":"Frog jump","text":"<p>Geek wants to climb from the 0th stair to the \\((n-1)_{th} stair\\). At a time the Geek can climb either one or two steps. A height array is also given. Whenever the geek jumps from stair i to stair j, the energy consumed in the jump is \\(abs(height_i - height_j)\\), where abs() means the absolute difference. return the minimum energy that can be used by the Geek to jump from stair 0 to stair N-1.</p>"},{"location":"dsa/dp/frog-jump/#top-down-approach","title":"Top Down Approach","text":"<pre><code>def minimumEnergy(self, height, l):\n    dp=[-1 for i in range(n+1)]\n    def energy(step: int):\n        if dp[step] != -1:\n            return dp[step]\n        if step == n - 1:\n            return 0\n        if step &gt;= n:\n            return math.inf\n        stepOne = math.inf\n        stepTwo= math.inf\n        if step + 1 &lt; n:\n            stepOne = abs(height[step] - height[step + 1]) + energy(step + 1)\n        if step + 2 &lt; n:\n            stepTwo = abs(height[step] - height[step + 2]) + energy(step + 2)\n        dp[n] = min(stepOne, stepTwo)\n        return dp[n]\n\n    energy(0)\n    return dp[n]\n</code></pre>"},{"location":"dsa/dp/frog-jump/#bottom-up-approach","title":"Bottom Up Approach","text":"<pre><code>def minimumEnergy(self, height, n):\n    dp=[math.inf for i in range(n)]\n    if len(height) == 1:\n        return 0\n    dp[0] = 0\n    dp[1] = abs(height[0] - height[1])\n    for stair in range(2, n):\n        stepOne = abs(height[stair - 1] - height[stair])\n        stepTwo = abs(height[stair - 2] - height[stair])\n        dp[stair] = min(dp[stair - 1] + stepOne, dp[stair - 2] + stepTwo)\n    return dp[n - 1]\n</code></pre>"},{"location":"dsa/dp/house-robber/","title":"House robber","text":"<p>Simliar to house robber but circular arrangement, use rob twice</p>"},{"location":"dsa/dp/maximum-sum-of-non-adjacent-elements/","title":"Maximum sum of non adjacent elements","text":"<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and\u00a0it will automatically contact the police if two adjacent houses were broken into on the same night.</p> <p>Return\u00a0the maximum amount of money you can rob tonight\u00a0without alerting the police.</p>"},{"location":"dsa/dp/maximum-sum-of-non-adjacent-elements/#top-down-approach","title":"Top Down Approach","text":"<pre><code>def rob(self, nums: List[int]) -&gt; int:\n    dp = [-1 for _ in range(len(nums))]\n    def go(house):\n        if house &gt;= len(nums):\n            return 0\n        if dp[house] != -1:\n            return dp[house]\n        dp[house] = max(nums[house] + go(house + 2), go(house + 1))\n        return dp[house]\n    return go(0)  \n</code></pre>"},{"location":"dsa/dp/maximum-sum-of-non-adjacent-elements/#bottom-up-approach","title":"Bottom Up Approach","text":"<pre><code>def rob(self, nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n    if len(nums) == 1:\n        return nums[0]\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for house in range(2, len(nums)):\n        dp[house] = max(nums[house] + dp[house - 2], dp[house - 1])\n    return dp[len(nums) - 1]\n</code></pre>"},{"location":"dsa/graph/","title":"Graph","text":"<p>Graph Data Structure\ud83d\udd78\ufe0f</p>"},{"location":"dsa/graph/#concepts","title":"Concepts","text":"Topic Status Introduction to Graphs #done\u2705 BFS #done\u2705 DFS #done\u2705"},{"location":"dsa/graph/#dfs-and-bfs-problems","title":"DFS and BFS problems","text":"Topic Status Number of Provinces #done\u2705 Rotten Oranges #done\u2705 Flood Fill #done\u2705 Cycle Detection #done\u2705 graph/01-matrix #done\u2705 Surrounded Regions #done\u2705 Number of Enclaves #done\u2705 Word Ladder #done\u2705 Bipartite Graph #done\u2705"},{"location":"dsa/graph/#topological-sort","title":"Topological Sort","text":"Topic Status Topological Sort #done\u2705 Course Schedule #done\u2705 Find eventual safe states #done\u2705 Alien Dictionary #done\u2705"},{"location":"dsa/graph/#shortest-path","title":"Shortest Path","text":"Topic Status Shortest Path in UG and DAG #done\u2705 Djisktras Algorithm #done\u2705 Shortest Path in binary maze #done\u2705 Path with minimum effort #done\u2705 Cheapest flight with k stops #todo\ud83d\udd8b\ufe0f Network delay time #done\u2705 Number of ways to arrive at destination #done\u2705 Minimum step to calculate #done\u2705 Bellman Ford Algorithms #done\u2705 Floyd Algorithms #done\u2705 Find city with smallest neighbour #done\u2705"},{"location":"dsa/graph/#minimum-spanning-tree","title":"Minimum Spanning Tree","text":"Topic Status Minimum Spanning Tree #done\u2705 Prims Algorithms #done\u2705 Disjoint Set #done\u2705 Kruskals Algorithm #done\u2705 Make network connected #done\u2705 Most stones removed #todo\ud83d\udd8b\ufe0f graph/accounts-merge #done\u2705 Number of Island 2 #done\u2705 Making a Island Large #done\u2705 Swim in rising water #done\u2705"},{"location":"dsa/graph/#other-topics","title":"Other Topics","text":"Topic Status Bridges in graph #todo\ud83d\udd8b\ufe0f Articulation points #todo\ud83d\udd8b\ufe0f Kosarajus Algorithm #todo\ud83d\udd8b\ufe0f"},{"location":"dsa/graph/01-matrix/","title":"01 matrix","text":"<p>Here, we need to find the nearest zero for each one</p> <p>So solve this, what we do is for each 0, we do a BFS, the search which reaches the nearest first, marks the nearest distance in that cell</p> <p>BFS reaches the shortest node</p> <pre><code>def updateMatrix(self, mat: List[List[int]]) -&gt; List[List[int]]:\n    queue = []\n    rows = len(mat)\n    cols = len(mat[0])\n    for row in range(rows):\n        for col in range(cols):\n            if mat[row][col] == 0:\n                queue.append([row, col])\n            else:\n                mat[row][col] = -1\n\n    visited = [[False for i in range(cols)] for j in range(rows)]\n    while len(queue) &gt; 0:\n        row, col = queue.pop(0)\n        for xx, yy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            p = row + xx\n            q = col + yy\n            if p &gt;= 0 and q &gt;= 0 and p &lt; rows and q &lt; cols and mat[p][q] == -1:\n                mat[p][q] = mat[row][col] + 1\n                queue.append([p, q])\n    return mat\n</code></pre>"},{"location":"dsa/graph/accounts-merge/","title":"Accounts merge","text":"<pre><code>def accountsMerge(self, accounts):\n        n = len(accounts)\n        email_map = {}\n        acc = [i for i in range(n)]\n        eml = [[] for i in range(n)]\n\n        def find(v, parent):\n            if parent[v] == v:\n                return v\n            p = find(parent[v], parent)\n            parent[v] = p\n            return p\n\n        def union(u, v, parent):\n            pu = find(u, parent)\n            pv = find(v, parent)\n            if pu == pv:\n                return\n            else:\n                parent[pu] = pv\n\n        for i, account in enumerate(accounts):\n            name, *emails = account\n            for email in emails:\n                if email in email_map:\n                    c = email_map[email]\n                    union(i, c, acc)\n                else:\n                    email_map[email] = i\n\n        for k, v in email_map.items():\n            eml[find(v, acc)].append(k)\n\n        ans = []\n        for i in range(n):\n            emails = eml[i]\n            name = accounts[acc[i]][0]\n            if len(emails) == 0:\n                continue\n            else:\n                ans.append([name, *sorted(emails)])\n        return ans\n</code></pre>"},{"location":"dsa/graph/alien-dictionary/","title":"Alien dictionary","text":"<p>Given a sorted dictionary of an alien language having N words and k starting alphabets of a standard dictionary. Find the order of characters in the alien language. E.g. dictionary =  {\"baa\",\"abcd\",\"abca\",\"cab\",\"cad\"} Output = b d a c </p> <pre><code>def alienDictionary(dictionary, n, k):\n    adj = {i:[] for i in 'abcdefghijklmnopqrstuvwxyz'}\n    indegree = {i:0 for i in 'abcdefghijklmnopqrstuvwxyz'}\n    for index, word in enumerate(dictionary[:-2]):\n        fst = word\n        snd = dictionary[index + 1]\n        for a, b in zip(fst, snd):\n            if a != b:\n                adj[a].append(b)\n                indegree[b] += 1\n                break\n    q = [i for i in 'abcdefghijklmnopqrstuvwxyz'[:k] if indegree[i] == 0]\n    ans = []\n    while len(q) != 0:\n        letter = q.pop(0)\n        ans.append(letter) \n        for next in adj[letter]:\n            indegree[next] -= 1\n            if indegree[next] == 0:\n                q.append(next)\n    print(ans)\n</code></pre>"},{"location":"dsa/graph/articulation-points/","title":"Articulation points","text":"<p>Articulation point is the vertex which when removed increases the number of components in the graph</p> <pre><code>def articulation_points(graph: Graph):\n    time = 0\n    is_ap = [False for _ in range(graph.nodes)] # if node u is a articulation point\n    disc = [0 for _ in range(graph.nodes)] # discovery time / discovery order to reach node u\n    low = [0 for _ in range(graph.nodes)] # lowest node through which you can reach u\n\n    def dfs(u, p):\n        nonlocal low, time, is_ap, disc\n        children = 0\n        time += 1\n        low[u] = disc[u] = time\n        for v in graph.adj[u]:\n            if v == p:\n                continue\n            if disc[v] == 0:\n                children += 1\n                dfs(v, u)\n                if disc[u] &lt;= low[v]:\n                    is_ap[u] = True\n                low[u] = min(low[u], low[v])\n            else:\n                low[u] = min(low[u], disc[v])\n        return children\n\n    for node in range(graph.nodes):\n        if disc[node] == 0:\n            is_ap[node] = dfs(node, node) &gt; 1\n\n    print(is_ap)\n</code></pre>"},{"location":"dsa/graph/bellman-ford-algorithms/","title":"Bellman ford algorithms","text":"<p>The Bellman-Ford algorithm guarantees that shortest paths can be correctly computed in\u00a0<code>V - 1</code>\u00a0iterations due to its approach to edge relaxation and the properties of shortest paths in graphs. Here's a deeper dive into why\u00a0<code>V - 1</code>\u00a0iterations are sufficient:</p>"},{"location":"dsa/graph/bellman-ford-algorithms/#concept-of-shortest-path","title":"Concept of Shortest Path","text":"<ol> <li>Path Lengths:<ul> <li>In a graph, the shortest path from a source vertex to any other vertex can be at most\u00a0<code>V - 1</code>\u00a0edges long if there are\u00a0<code>V</code>\u00a0vertices. This is because a path that uses more than\u00a0<code>V - 1</code>\u00a0edges would necessarily involve revisiting some vertices, potentially creating a cycle.</li> </ul> </li> </ol>"},{"location":"dsa/graph/bellman-ford-algorithms/#edge-relaxation","title":"Edge Relaxation","text":"<ol> <li> <p>Relaxation:</p> <ul> <li> <p>Relaxing an edge\u00a0<code>(u, v)</code>\u00a0with weight\u00a0<code>w</code>:\u00a0If the current known distance to vertex\u00a0<code>v</code>\u00a0can be shortened by taking the edge from\u00a0<code>u</code>\u00a0to\u00a0<code>v</code>, then update the distance:</p> <p>python</p> <p>Copy code</p> <p><code>if distance[u] + w &lt; distance[v]:     distance[v] = distance[u] + w</code></p> </li> </ul> </li> <li> <p>Relaxation Process Over\u00a0<code>V - 1</code>\u00a0Iterations:</p> <ul> <li>During each iteration, every edge in the graph is examined and relaxed if a shorter path is found. The process of relaxing edges allows the algorithm to progressively build up the shortest path estimates.</li> </ul> </li> </ol>"},{"location":"dsa/graph/bellman-ford-algorithms/#why-v-1-iterations-are-enough","title":"Why\u00a0<code>V - 1</code>\u00a0Iterations Are Enough","text":"<ol> <li> <p>Path Length and Relaxation:</p> <ul> <li>In a shortest path that uses up to\u00a0<code>V - 1</code>\u00a0edges, the maximum number of edges involved is\u00a0<code>V - 1</code>. This is because any path that uses\u00a0<code>V</code>\u00a0or more edges would necessarily contain cycles. The algorithm needs\u00a0<code>V - 1</code>iterations to ensure that all possible paths up to\u00a0<code>V - 1</code>\u00a0edges are considered.</li> </ul> </li> <li> <p>Convergence of Shortest Paths:</p> <ul> <li>After\u00a0<code>V - 1</code>\u00a0iterations, the algorithm will have relaxed all edges enough times to ensure that the shortest path distances are correct. This is because every path from the source to any vertex that uses up to\u00a0<code>V - 1</code>\u00a0edges will have been fully considered.</li> </ul> </li> </ol>"},{"location":"dsa/graph/bellman-ford-algorithms/#code","title":"Code","text":"<pre><code>def bellman_ford(self, V, edges, S):\n    dist = [100000000 for i in range(V)]\n    dist[S] = 0\n    for i in range(V):\n        for u, v, w in edges:\n            newDist = dist[u] + w\n            if dist[u] != 100000000 and newDist &lt; dist[v]:\n                dist[v] = newDist\n    for u, v, w in edges:\n        newDist = dist[u] + w\n        if dist[u] != 100000000 and newDist &lt; dist[v]:\n            return [-1]\n\n    return dist\n</code></pre>"},{"location":"dsa/graph/bfs/","title":"Bfs","text":"<p>Breadth first search in a graph traverses from starting node to each of the neighbors and then next neighbors <pre><code>def bfsOfGraph(V, adj):\n    visited = [False] * V\n    queue = [0]\n    ans = []\n    while len(queue) &gt; 0:\n        node = queue.pop(0)\n        if visited[node]:\n            continue\n        visited[node] = True\n        for neighbour in adj[node]:\n            queue.append(neighbour)\n        ans.append(node)\n    return ans\n</code></pre></p>"},{"location":"dsa/graph/bipartite-graph/","title":"Bipartite graph","text":"<p>A graph is\u00a0bipartite\u00a0if the nodes can be partitioned into two independent sets\u00a0<code>A</code>\u00a0and\u00a0<code>B</code>\u00a0such that\u00a0every\u00a0edge in the graph connects a node in set\u00a0<code>A</code>\u00a0and a node in set\u00a0<code>B</code></p> <pre><code>def isBipartite(graph):\n    colors = [0] * len(graph)\n    def helper(node, color):\n        nonlocal colors\n        if colors[node] != 0:\n            return colors[node] == color\n        colors[node] = color\n        for neighbour in graph[node]:\n            if not helper(neighbour, -color):\n                return False\n        return True\n    for i in range(len(graph)):\n        if colors[i] == 0 and not helper(i, 1):\n            return False\n    return True\n</code></pre>"},{"location":"dsa/graph/bridges-in-graph/","title":"Bridges in graph","text":"<p>Bridge in the graph is a edge that when removed increases the number of components in the graph</p> <pre><code>def articulation_points(graph: Graph):\n    time = 0\n    is_ap = [False for _ in range(graph.nodes)] # if node u is a articulation point\n    disc = [0 for _ in range(graph.nodes)] # discovery time / discovery order to reach node u\n    low = [0 for _ in range(graph.nodes)] # lowlink is the minimum node which can be reached from node u\n\n    def dfs(u, p):\n        nonlocal low, time, is_ap, disc\n        time += 1\n        low[u] = disc[u] = time\n        for v in graph.adj[u]:\n            if v == p:\n                continue\n            if disc[v] == 0:\n                children += 1\n                dfs(v, u)\n                if disc[u] &lt; low[v]:\n                    is_ap[u] = True\n                low[u] = min(low[u], low[v])\n            else:\n                low[u] = min(low[u], disc[v])\n\n    for node in range(graph.nodes):\n        if disc[node] == 0:\n            dfs(node, node)\n\n    print(is_ap)\n</code></pre>"},{"location":"dsa/graph/course-schedule/","title":"Course schedule","text":"<p>Kahn's Algorithms Based</p>"},{"location":"dsa/graph/cycle-detection/","title":"Cycle detection","text":""},{"location":"dsa/graph/cycle-detection/#indirect-graph","title":"Indirect Graph","text":""},{"location":"dsa/graph/cycle-detection/#using-bfs","title":"Using BFS","text":"<pre><code>visited=[False] * V\n\ndef\u00a0isCycle(v,adj):\n    queue = [[v,-1]]\u00a0\u00a0\n    while\u00a0len(queue) &gt; 0:\n        node,parent = queue.pop(0)\n        visited[node] = True\n        for\u00a0neighbour\u00a0in\u00a0adj[node]:\n            if\u00a0not\u00a0visited[neighbour]:\n                queue.append([neighbour,node])\n            elif\u00a0neighbour != parent:\n                return\u00a0True\n    return\u00a0False\n\nans = False\nfor\u00a0i\u00a0in\u00a0range(V):\n    if\u00a0visited[i]:\n        continue\n    ans =\u00a0ans\u00a0or\u00a0isCycle(i, adj)\nprint(ans)\n</code></pre>"},{"location":"dsa/graph/cycle-detection/#using-dfs","title":"Using DFS","text":"<pre><code>visited=[False] * V\n\ndef\u00a0isCycle(v, parent, adj):\n    visited[v] = True\n    for\u00a0neighbour\u00a0in\u00a0adj[v]:\n        if\u00a0not\u00a0visited[neighbour]:\n            if\u00a0solve(neighbour,v,adj) == True:\n                return\u00a0True\n        elif\u00a0neighbour\u00a0!= parent:\n            return\u00a0True\n    return\u00a0False\n\nans = False\nfor\u00a0i\u00a0in\u00a0range(V):\n    if\u00a0visited[i]:\n        continue\n    ans=\u00a0ans\u00a0or\u00a0isCycle(i, -1, adj)\n</code></pre>"},{"location":"dsa/graph/cycle-detection/#direct-graph","title":"Direct Graph","text":""},{"location":"dsa/graph/cycle-detection/#todo","title":"todo\ud83d\udd8b\ufe0f","text":""},{"location":"dsa/graph/dfs/","title":"Dfs","text":"<p>Depth first search in a graph traverses the graph in depth first fashion i.e. traversing a single child and it's child node and so on, until there is no child node <pre><code>def dfsOfGraph(V, adj):\n    visited = [False] * V\n    ans = []\n    def helper(node, adj):\n        nonlocal visited, ans\n        if visited[node]:\n            return\n        visited[node] = True\n        ans.append(node)\n        for neighbour in adj[node]:\n            helper(neighbour, adj)\n    helper(0, adj)\n    return ans\n</code></pre></p>"},{"location":"dsa/graph/disjoint-set/","title":"Disjoint set","text":"<p>Disjoint set data structure <pre><code>def find(A, X):\n    p = A[X - 1]\n    if p == X:\n        return X\n    else:\n        A[X - 1] = find(A, p)\n        return A[X - 1]\n\ndef unionSet(A, X, Z):\n    pX = find(A, X)\n    pZ = find(A, Z)\n    A[pX - 1] = pZ\n</code></pre></p>"},{"location":"dsa/graph/disjoint-set/#union-by-rank","title":"Union By Rank","text":"<pre><code>def find(A, X):\n    p = A[X - 1]\n    if p == X:\n        return X\n    else:\n        A[X - 1] = find(A, p)\n        return A[X - 1]\n\ndef unionSet(A, X, Z, rank):\n    pX = find(A, X)\n    pZ = find(A, Z)\n    if pX == pZ: return\n    if rank[pX] &lt; rank[pZ]:\n        A[pX - 1] = pZ\n    elif rank[pX] &gt; rank[pZ]:\n        A[pZ - 1] = pX\n    else:\n        A[pX - 1] = pZ\n        rank[pZ - 1] = rank[pZ - 1] + 1\n</code></pre>"},{"location":"dsa/graph/disjoint-set/#union-by-size","title":"Union By Size","text":"<pre><code>def find(A, X):\n    p = A[X - 1]\n    if p == X:\n        return X\n    else:\n        A[X - 1] = find(A, p)\n        return A[X - 1]\n\ndef unionSet(A, X, Z, size):\n    pX = find(A, X)\n    pZ = find(A, Z)\n    if pX == pZ: return\n    if size[pX] &lt; size[pZ]:\n        A[pX - 1] = pZ\n        size[pX] = size[pX] + size[pZ]\n    else:\n        A[pZ - 1] = pX\n        size[pZ] = size[pX] + size[pZ]\n</code></pre>"},{"location":"dsa/graph/djisktras-algorithm/","title":"Djisktras algorithm","text":"<p>Djikstras Algorithm visits the node with the shortest distance to source first</p> <pre><code>def dijkstra(self, n, adj, src):\n        dist = [1e9] * n\n        dist[src] = 0\n        visited = [False] * n\n\n        for _ in range(n):\n\n            min_dist_in_set = 1e9\n            # node closest to source\n            min_dist_node = src\n            for node in range(n):\n                if not visited[node] and dist[node] &lt; min_dist_in_set:\n                    min_dist_in_set = dist[node]\n                    min_dist_node = node\n\n            visited[min_dist_node] = True\n\n            for neighbour, wt in adj[min_dist_node]:\n                new_dist = dist[min_dist_node] + wt\n                if new_dist &lt; dist[neighbour]:\n                    dist[neighbour] = new_dist\n        return dist \n</code></pre>"},{"location":"dsa/graph/find-city-with-smallest-neighbour/","title":"Find city with smallest neighbour","text":"<pre><code>def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int):\n    dist = [[math.inf for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n    for u, v, w in edges:\n        dist[u][v] = dist[v][u] = w\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    minReachableCities = float('inf')\n    bestCity = -1\n    for i in range(n):\n        reachableCities = 0\n        for j in range(n):\n            if dist[i][j] &lt;= distanceThreshold:\n                reachableCities += 1\n        if reachableCities &lt;= minReachableCities:\n            minReachableCities = reachableCities\n            bestCity = i\n    return bestCity\n</code></pre>"},{"location":"dsa/graph/find-eventual-safe-states/","title":"Find eventual safe states","text":"<pre><code>def eventualSafeNodes(self, graph: List[List[int]]) -&gt; List[int]:\n    indegree = [0] * len(graph)\n    adj = [[] for i in range(len(graph))]\n    for node in range(len(graph)):\n        for neighbour in graph[node]:\n            adj[neighbour].insert(0, node)\n            indegree[node] += 1\n\n    q = []\n    for node in range(len(indegree)):\n        if indegree[node] == 0:\n            q.insert(0, node)\n\n    safe = [False for i in range(len(graph))]\n    while len(q) != 0:\n        node = q.pop(0)\n        safe[node] = True\n        for nextNode in adj[node]:\n            indegree[nextNode] -= 1\n            if indegree[nextNode] == 0:\n                q.append(nextNode)\n    return [i for i in range(len(safe)) if safe[i] == True]\n</code></pre>"},{"location":"dsa/graph/flood-fill/","title":"Flood fill","text":"<pre><code>\u00a0 \u00a0 def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -&gt; List[List[int]]:\n\n\u00a0 \u00a0 \u00a0 \u00a0 n = len(image)\n\n\u00a0 \u00a0 \u00a0 \u00a0 m = len(image[0])\n\n\u00a0 \u00a0 \u00a0 \u00a0 queue = [[sr, sc]]\n\n\u00a0 \u00a0 \u00a0 \u00a0 while len(queue) &gt; 0:\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 x, y = queue.pop(0)\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for xx, yy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p, q = x + xx, y + yy\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if p &gt;= 0 and p &lt; n and q &gt;= 0 and q &lt; m and image[p][q] != color and image[x][y] == image[p][q]:\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 queue.append([p, q])\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 image[x][y] = color\n\n\u00a0 \u00a0 \u00a0 \u00a0 return image\n</code></pre>"},{"location":"dsa/graph/floyd-algorithms/","title":"Floyd algorithms","text":"<p>The recurrence is\u00a0 \\(\\(\ud835\udc51\ud835\udc56\ud835\udc60\ud835\udc61(\ud835\udc56,\ud835\udc57,\ud835\udc58)=\ud835\udc5a\ud835\udc56\ud835\udc5b(\ud835\udc51\ud835\udc56\ud835\udc60\ud835\udc61(\ud835\udc56,\ud835\udc57,\ud835\udc58\u22121),\u00a0\ud835\udc51\ud835\udc56\ud835\udc60\ud835\udc61(\ud835\udc56,\ud835\udc58,\ud835\udc58\u22121)+\ud835\udc51\ud835\udc56\ud835\udc60\ud835\udc61(\ud835\udc58,\ud835\udc57,\ud835\udc58\u22121))\\)\\) with the base case\u00a0\ud835\udc51\ud835\udc56\ud835\udc60\ud835\udc61(\ud835\udc56,\ud835\udc57,0)=\ud835\udc64(\ud835\udc56,\ud835\udc57). There is only one way we can achieve this iteratively, by calculating all cases of\u00a0\ud835\udc58\u22121\u00a0before calculating cases of\u00a0\ud835\udc58.</p> <pre><code>def floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int):\n    dist = [[math.inf for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n    for u, v, w in edges:\n        dist[u][v] = dist[v][u] = w\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n</code></pre>"},{"location":"dsa/graph/introduction-to-graphs/","title":"Introduction to graphs","text":"<p>A data structure consisting of nodes connected to other nodes with edges - Order: The number of vertices in the graph - Size: The number of edges in the graph - Vertex degree: The number of edges that are incident to a vertex - Isolated vertex: A vertex that is not connected to any other vertices in the graph - Self-loop: An edge from a vertex to itself - Directed graph: A graph where all the edges have a direction indicating what is the start vertex and what is the end vertex - Undirected graph: A graph with edges that have no direction - Weighted graph: Edges of the graph has weights - Unweighted graph: Edges of the graph has no weights</p>"},{"location":"dsa/graph/kruskals-algorithm/","title":"Kruskals algorithm","text":"<p>Kruskal's algorithm finds a\u00a0minimum spanning forest\u00a0of an undirected\u00a0edge-weighted graph (\"Weighted graph\"). If the graph is\u00a0==connected==, it finds a\u00a0minimum spanning tree. It is a\u00a0greedy algorithm\u00a0that in each step adds to the forest the lowest-weight edge that will not form a\u00a0cycle \"Cycle (graph theory)\".\u00a0The key steps of the algorithm are\u00a0sorting\u00a0to detect cycles. Its running time is dominated by the time to sort all of the graph edges by their weight.</p> <pre><code>def spanningTree(self, V, adj):\n    parent = [i for i in range(V)]\n    edges = []\n    for u in range(V):\n        for v, w in adj[u]:\n            edges.append((u, v, w))\n    minsum = 0\n\n    def find(v, parent):\n        if parent[v] == v:\n            return v\n        p = find(parent[v], parent)\n        parent[v] = p\n        return p\n\n    def union(u, v, w, parent):\n        nonlocal minsum\n        pu = find(u, parent)\n        pv = find(v, parent)\n        if pu == pv:\n            return\n        else:\n            parent[pu] = pv\n            minsum += w\n    edges = sorted(edges, key=lambda x: x[2])\n    for u, v, w in edges:\n        union(u, v, w, parent)\n    return minsum\n</code></pre>"},{"location":"dsa/graph/make-network-connected/","title":"Make network connected","text":"<pre><code>def makeConnected(n, connections):\n\n    if len(connections) &lt; n - 1:\n        return -1\n\n    parent = [i for i in range(n)]\n\n    def find(v, parent):\n        if parent[v] == v:\n            return v\n        p = find(parent[v], parent)\n        parent[v] = p\n        return p\n\n    def union(u, v, parent):\n        pu = find(u, parent)\n        pv = find(v, parent)\n\n        if pu == pv:\n            return\n        else:\n            parent[pu] = pv\n\n    for u, v in connections:\n        union(u, v, parent)\n\n    components = 0\n\n    for i in range(n):\n        if parent[i] == i:\n            components += 1\n\n    return components - 1\n</code></pre>"},{"location":"dsa/graph/making-a-island-large/","title":"Making a island large","text":"<pre><code>class Solution:\n    def largestIsland(self, grid: List[List[int]]) -&gt; int:\n        # standard find and union\n        def find(v, parent):\n            if parent[v] == v:\n                return v\n            p = find(parent[v], parent)\n            parent[v] = p\n            return p\n        def union(u, v, parent):\n            pu = find(u, parent)\n            pv = find(v, parent)\n            if pu == pv:\n                return\n            else:\n                parent[pu] = pv\n\n        n = len(grid)\n        parent = [i for i in range(n * n)]\n\n        # first we find all the components\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 0: continue\n                fi = i * n + j\n                for p, q in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                    x = i + p\n                    y = j + q\n                    if x &gt;= 0 and x &lt; n and y &gt;= 0 and y &lt; n and grid[x][y] == 1:\n                        si = x * n + y\n                        if find(fi, parent) != find(si, parent):\n                            union(fi, si, parent)\n\n        # find size of each component (can be done by union by size)\n        size = [0 for i in range(n * n)]\n        for idx in range(n * n):\n            size[find(idx, parent)] += 1\n\n        ans = max(size)\n        # now we try to find a node which join adjoining components\n        # total size of result component would be \n        # total = sum of sizes of adjoining components + 1\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1: continue\n                adj = set()\n                for p, q in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                    x = i + p\n                    y = j + q\n                    if x &gt;= 0 and x &lt; n and y &gt;= 0 and y &lt; n and grid[x][y] == 1:\n                        si = x * n + y\n                        adj.add(find(si, parent))\n                total = 0\n                for c in adj:\n                    total += size[c]\n                ans = max(ans, total + 1)\n\n        return ans\n</code></pre>"},{"location":"dsa/graph/minimum-spanning-tree/","title":"Minimum spanning tree","text":"<p>Among all possible spanning trees of a graph, the minimum spanning tree is the one for which the sum of all the edge weights is the minimum</p> <p>Choose the smallest edge to find the MST (Prim's Algorithm) <pre><code>def spanningTree(self, V, adj):\n    heap = [(0, 0)]\n    mstSum = 0\n    visited = [False] * V\n    while heap:\n        wt, node = heapq.heappop(heap)\n        if visited[node]: continue\n        mstSum = mstSum + wt\n        visited[node] = True\n        for neigh, w in adj[node]:\n            heapq.heappush(heap, (w, neigh))\n    return mstSum\n</code></pre></p>"},{"location":"dsa/graph/minimum-step-to-calculate/","title":"Minimum step to calculate","text":"<pre><code>def minimumMultiplications(self, arr : List[int], s : int, e: int) -&gt; int:\n    heap = [(0, s)]\n    minSteps = [math.inf for i in range(100000)]\n    minSteps[s] = 0\n    while heap:\n        step, start = heapq.heappop(heap)\n        if start == e:\n            return minSteps[e]\n        for n in arr:\n            newStart = (n * start) % 100000\n            if step + 1 &lt; minSteps[newStart]:\n                minSteps[newStart] = step + 1\n                heapq.heappush(heap, (step + 1, newStart))\n    return -1\n</code></pre>"},{"location":"dsa/graph/network-delay-time/","title":"Network delay time","text":"<pre><code>def networkDelayTime(self, times: List[List[int]], n: int, k: int) -&gt; int:\n    adj = [[] for i in range(n)]\n    for node in times:\n        u, v, w = node\n        adj[u - 1].append((w, v - 1))\n\n    dist = [1e9 for i in range(n)]\n    dist[k - 1] = 0\n    minheap = [(0, k - 1)]\n\n    while minheap:  \n        w1, u = heappop(minheap)\n        for node in adj[u]:\n            w2, v = node \n            if dist[v] &gt; dist[u] + w2: \n                dist[v] = dist[u] + w2   \n                heappush(minheap, (dist[v], v))\n\n    ans = max(dist)\n    return ans if ans is not 1e9 else -1\n</code></pre>"},{"location":"dsa/graph/number-of-enclaves/","title":"Number of enclaves","text":"<p>Here, we need to find all the ones, from which we cannot step outside the grid when travelling 4-directionally</p> <p>So, first we find all the 1's that are at the edge of the grid, and then do BFS from them, reducing the total count of 1's <pre><code>def numEnclaves(grid: List[List[int]]):\n    queue = []\n    rs = len(grid)\n    cs = len(grid[0])\n    total = 0\n    for i in range(rs):\n        for j in range(cs):\n            total += grid[i][j]\n            if (i == 0 or i == rs - 1 or j == 0 or j == cs - 1) and grid[i][j] == 1:\n                total -= 1\n                grid[i][j] = 0\n                queue.append([i, j])\n    while len(queue) &gt; 0:\n        i, j = queue.pop(0)\n        for xx, yy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            p = i + xx\n            q = j + yy\n            if p &gt;= 0 and p &lt; rs and q &gt;= 0 and q &lt; cs and grid[p][q] == 1:\n                grid[p][q] = 0\n                total -= 1\n                queue.append([p, q])\n    return total\n</code></pre></p>"},{"location":"dsa/graph/number-of-island-2/","title":"Number of island 2","text":"<pre><code>vector&lt;int&gt; numOfIslands(int n, int m,\n    vector&lt;vector&lt;int&gt;&gt; &amp;operators) {\n    DisjointSet ds(n * m);\n    int vis[n][m];\n    memset(vis, 0, sizeof vis);\n    int cnt = 0;\n    vector&lt;int&gt; ans;\n    for (auto it : operators) {\n        int row = it[0];\n        int col = it[1];\n        if (vis[row][col] == 1) {\n            ans.push_back(cnt);\n            continue;\n        }\n        vis[row][col] = 1;\n        cnt++;\n        // row - 1, col\n        // row , col + 1\n        // row + 1, col\n        // row, col - 1;\n        int dr[] = { -1, 0, 1, 0};\n        int dc[] = {0, 1, 0, -1};\n        for (int ind = 0; ind &lt; 4; ind++) {\n            int adjr = row + dr[ind];\n            int adjc = col + dc[ind];\n            if (isValid(adjr, adjc, n, m)) {\n                if (vis[adjr][adjc] == 1) {\n                    int nodeNo = row * m + col;\n                    int adjNodeNo = adjr * m + adjc;\n                    if (ds.findUPar(nodeNo) != ds.findUPar(adjNodeNo)) {\n                        cnt--;\n                        ds.unionBySize(nodeNo, adjNodeNo);\n                    }\n                }\n            }\n        }\n        ans.push_back(cnt);\n    }\n    return ans;\n}\n</code></pre>"},{"location":"dsa/graph/number-of-provinces/","title":"Number of provinces","text":"<p>Find the number of provinces where each province is a group of nodes connected to each other. Here the observation is that each province is a graph, so we need to count the graph, to do that we traverse each graph and track a count of each traversal. <pre><code>def findCircleNum(self, isConnected: List[List[int]]) -&gt; int:\n    total = len(isConnected)\n    visited = [False] * total\n    ans = 0\n    # dfs or you can use bfs\n    def helper(node):\n        nonlocal visited, total\n        if visited[node]:\n            return\n        visited[node] = True\n        for neighbour in range(total):\n            if isConnected[node][neighbour]:\n                helper(neighbour)\n    # traverse each graph and track count\n    for i in range(total):\n        if visited[i]:\n            continue\n        ans = ans + 1\n        helper(i)\n    return ans\n</code></pre></p>"},{"location":"dsa/graph/number-of-ways-to-arrive-at-destination/","title":"Number of ways to arrive at destination","text":"<pre><code>def countPaths(self, n: int, roads: List[List[int]]) -&gt; int:\n\n    adj = [[] for i in range(n)]\n\n    for road in roads:\n\n        u, v, w = road\n\n        adj[u].append((w, v))\n\n        adj[v].append((w, u))\n\n    heap = [(0, 0)]\n\n    mindist = [math.inf for i in range(n)]\n\n    mindist[0] = 0\n\n    count = [0 for i in range(n)]\n\n    count[0] = 1\n\n    while heap:\n\n        w1, s = heappop(heap)\n\n        if mindist[s] &lt; w1: continue\n\n        for road in adj[s]:\n\n            w2, d = road\n\n            if mindist[d] &gt; mindist[s] + w2:\n\n            mindist[d] = mindist[s] + w2\n\n            count[d] = count[s]\n\n            heappush(heap, (mindist[d], d))\n\n            elif mindist[d] == mindist[s] + w2:\n\n            count[d] = (count[d] + count[s]) % 1_000_000_007\n\n    return count[n - 1]\n</code></pre>"},{"location":"dsa/graph/path-with-minimum-effort/","title":"Path with minimum effort","text":""},{"location":"dsa/graph/path-with-minimum-effort/#solution-without-minheap","title":"Solution without minHeap","text":"<pre><code>def minimumEffortPath(self, heights: List[List[int]]) -&gt; int:\n\n\u00a0 \u00a0 \u00a0 \u00a0 n = len(heights)\n\n\u00a0 \u00a0 \u00a0 \u00a0 m = len(heights[0])\n\n\u00a0 \u00a0 \u00a0 \u00a0 start = (0, 0)\n\n\u00a0 \u00a0 \u00a0 \u00a0 end = (n - 1, m - 1)\n\n\n\n\u00a0 \u00a0 \u00a0 \u00a0 min_effort = [[0 for i in range(m)] for i in range(n)]\n\n\u00a0 \u00a0 \u00a0 \u00a0 min_effort[0][0] = 0\n\n\n\n\u00a0 \u00a0 \u00a0 \u00a0 visited = [[False for i in range(m)] for i in range(n)]\n\n\u00a0 \u00a0 \u00a0 \u00a0 dist = [[1e9 for _ in range(m)] for i in range(n)]\n\n\u00a0 \u00a0 \u00a0 \u00a0 dist[0][0] = 0\n\n\n\n\u00a0 \u00a0 \u00a0 \u00a0 for _ in range(n * m):\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 min_dist = 1e9\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 min_node = (0, 0)\n\n\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for x in range(n):\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for y in range(m):\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if not visited[x][y] and dist[x][y] &lt; min_dist:\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 min_dist = dist[x][y]\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 min_node = (x, y)\n\n\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 x, y = min_node\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 visited[x][y] = True\n\n\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if min_node == end:\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return dist[n - 1][m - 1]\n\n\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 for i, j in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 p = x + i\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 q = y + j\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if p &gt;= 0 and p &lt; n and q &gt;= 0 and q &lt; m:\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dist[p][q] = min(max(abs(heights[p][q] - heights[x][y]), dist[x][y]), dist[p][q])\n\n\u00a0 \u00a0 \u00a0 \u00a0 return dist[n - 1][m - 1]\n</code></pre>"},{"location":"dsa/graph/path-with-minimum-effort/#solution-with-minheap","title":"Solution with minHeap","text":"<pre><code>def minimumEffortPath(self, heights):\n        m, n = len(heights), len(heights[0])\n        dist = [[math.inf] * n for _ in range(m)]\n        dist[0][0] = 0\n        minHeap = [(0, 0, 0)] # distance, row, col\n        DIR = [0, 1, 0, -1, 0]\n\n        while minHeap:\n            d, r, c = heappop(minHeap)\n            if d &gt; dist[r][c]: continue  # this is an outdated version -&gt; skip it\n            if r == m - 1 and c == n - 1:\n                return d  # Reach to bottom right\n\n            for i in range(4):\n                nr, nc = r + DIR[i], c + DIR[i+1]\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                    newDist = max(d, abs(heights[nr][nc] - heights[r][c]))\n                    if dist[nr][nc] &gt; newDist:\n                        dist[nr][nc] = newDist\n                        heappush(minHeap, (dist[nr][nc], nr, nc))\n</code></pre>"},{"location":"dsa/graph/prims-algorithms/","title":"Prims algorithms","text":"<p>Refer Minimum Spanning Tree</p>"},{"location":"dsa/graph/rotten-oranges/","title":"Rotten oranges","text":"<pre><code>def orangesRotting(self, grid: List[List[int]]) -&gt; int:\n    queue = []\n    fresh = 0\n    n = len(grid)\n    m = len(grid[0])\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 2:\n                queue.append([i, j])\n            if grid[i][j] == 1:\n                fresh = fresh + 1\n    minutes = 0\n    while len(queue) &gt; 0 and fresh != 0:\n        size = len(queue)\n        minutes = minutes + 1\n        for i in range(size):\n            x, y = queue.pop(0)\n            for xx, yy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                p, q = x + xx, y + yy\n                if p &gt;= 0 and p &lt; n and q &gt;= 0 and q &lt; m and grid[p][q] == 1:\n                    grid[p][q] = 2\n                    queue.append([p, q])\n                    fresh = fresh - 1\n    if fresh != 0:\n        return -1\n    else:\n        return minutes\n</code></pre>"},{"location":"dsa/graph/shortest-path-in-binary-maze/","title":"Shortest path in binary maze","text":"<pre><code>def shortestPathBinaryMatrix(self, grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    start = (0, 0)\n    end = (n - 1, n - 1)\n\n    distance = [[0 for i in range(n)] for i in range(n)]\n    distance[0][0] = 1\n\n\n\n    grid[0][0] = 2\n\n    queue = [start]\n\n\n\n    while len(queue) &gt; 0:\n\n        x, y = queue.pop(0)\n\n        for i, j in [(1, 1), (-1, -1), (1, -1), (-1, 1), (0, 1), (0, -1), (1, 0), (-1, 0)]:\n\n            p = x + i\n\n            q = y + j\n\n            if p &gt;= 0 and p &lt; n and q &gt;= 0 and q &lt; n and grid[p][q] == 0:\n\n                queue.append((p, q))\n\n                grid[p][q] = 2\n\n                distance[p][q] = distance[x][y] + 1\n\n    if distance[n - 1][n - 1] == 0:\n\n        return -1\n\n    else:\n\n        return distance[n - 1][n - 1]\n</code></pre>"},{"location":"dsa/graph/shortest-path-in-ug-and-dag/","title":"Shortest path in ug and dag","text":""},{"location":"dsa/graph/shortest-path-in-ug-and-dag/#shortest-path-in-ug","title":"Shortest Path in UG","text":"<pre><code>def shortestPath(self, edges, n, m, src):\n    dist = [1e9] * n\n    adj = [[] for i in range(n)]\n    for edge in edges:\n        adj[edge[0]].append(edge[1])\n        adj[edge[1]].append(edge[0])\n    dist[src] = 0\n    visited = [False] * n\n    visited[src] = True\n    q = [src]\n    while len(q) != 0:\n        node = q.pop(0)\n        for neighbour in adj[node]:\n            if visited[neighbour]:\n                continue\n            dist[neighbour] = dist[node] + 1\n            visited[neighbour] = True\n            q.append(neighbour)\n    return [d if d != 1e9 else -1 for d in dist]\n</code></pre>"},{"location":"dsa/graph/surrounded-regions/","title":"Surrounded regions","text":"<p>Here we need to flip all 'O's which are directly or indirectly not in touch a 'O' at the edge</p> <p>So we do a DFS from 'O's at the edges, and mark all neighbors '#', then we traverse again traverse the board and flip 'O's which are not marked <pre><code>def solve(self, board: List[List[str]]) -&gt; None:\n    rows = len(board)\n    cols = len(board[0])\n    def dfs(row, col):\n        nonlocal rows, cols\n        board[row][col] = '#'\n        for xx, yy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            p, q = row + xx, col + yy\n            if p &gt;= 0 and q &gt;= 0 and p &lt; rows and q &lt; cols and board[p][q] == 'O':\n                dfs(p, q)\n    for row in range(rows):\n        for col in range(cols):\n            if (row == 0 or col == 0 or row == rows - 1 or col == cols - 1) and board[row][col] == 'O':\n                dfs(row, col)\n    for row in range(rows):\n        for col in range(cols):\n            if board[row][col] == 'O':\n                board[row][col] = 'X'\n            if board[row][col] == '#':\n                board[row][col] = 'O'\n</code></pre></p>"},{"location":"dsa/graph/swim-in-rising-water/","title":"Swim in rising water","text":"<pre><code> def swimInWater(self, grid: List[List[int]]) -&gt; int:\n        n = len(grid)\n        start = (0, 0)\n        end = (n - 1, n - 1)\n        t = 0\n        heap = [[grid[0][0], (0, 0)]]\n        visited = [[False for i in range(n)] for i in range(n)]\n        maxTime = 0\n        while True:\n            time, cell = heappop(heap)\n            print(time, grid[cell[0]][cell[1]], cell)\n            maxTime = max(time, maxTime)\n            if cell == end:\n                return maxTime\n            i, j = cell\n            visited[i][j] = True\n            for p, q in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                x = p + i\n                y = q + j\n                if x &gt;= 0 and x &lt; n and y &gt;= 0 and y &lt; n and not visited[x][y]:\n                    f = grid[i][j]\n                    t = grid[x][y]\n                    heappush(heap, [t, (x, y)])\n</code></pre>"},{"location":"dsa/graph/topological-sort/","title":"Topological sort","text":"<p>Topological sorting for\u00a0Directed Acyclic Graph (DAG)\u00a0is a linear ordering of vertices such that for every directed edge u-v, vertex\u00a0u\u00a0comes before\u00a0v\u00a0in the ordering</p> <p>Topological sort is not possible for undirected graph or graph having a cycle</p> <p>The basic idea to traverse the node and store the visited node in a stack, important thing to note is the use of stack.</p>"},{"location":"dsa/graph/topological-sort/#using-dfs","title":"Using DFS","text":"<pre><code># Function to perform Topological Sort\ndef topologicalSort(adj, V):\n    # Stack to store the result\n    stack = []\n    visited = [False] * V\n\n    def helper(v, adj):\n        nonlocal visited, stack\n        # Mark the current node as visited\n        visited[v] = True\n\n        # Recur for all adjacent vertices\n        for i in adj[v]:\n            if not visited[i]:\n                helper(i, adj)\n\n        # Push current vertex to stack which stores the result\n        stack.append(v)\n\n    # Call the recursive helper function to store\n    # Topological Sort starting from all vertices one by\n    # one\n    for i in range(V):\n        if not visited[i]:\n            helper(i, adj)\n\n    # Print contents of stack\n    print(\"Topological sorting of the graph:\", end=\" \")\n    while stack:\n        print(stack.pop(), end=\" \")\n</code></pre>"},{"location":"dsa/graph/topological-sort/#using-bfs-kahns-algorithm","title":"Using BFS (Kahn's Algorithm)","text":"<pre><code>def topologicalSort(V, adj):\n        # Create a list to store in-degree of all vertices\n        in_degree = [0] * V\n\n        # Traverse adjacency lists to fill in_degree of vertices\n        for i in range(V):\n            for j in adj[i]:\n                in_degree[j] += 1\n\n        # Create a queue and enqueue all vertices with in-degree 0\n        q = []\n        for i in range(self.V):\n            if in_degree[i] == 0:\n                q.append(i)\n\n        # Initialize count of visited vertices\n        count = 0\n\n        # Create a list to store topological order\n        top_order = []\n\n        # One by one dequeue vertices from queue and enqueue\n        # adjacent vertices if in-degree of adjacent becomes 0\n        while q:\n            # Extract front of queue (or perform dequeue)\n            # and add it to topological order\n            u = q.pop(0)\n            top_order.append(u)\n\n            # Iterate through all its neighbouring nodes\n            # of dequeued node u and decrease their in-degree\n            # by 1\n            for node in adj[u]:\n                # If in-degree becomes zero, add it to queue\n                in_degree[node] -= 1\n                if in_degree[node] == 0:\n                    q.append(node)\n\n            count += 1\n\n        # Check if there was a cycle\n        if count != V:\n            print(\"Graph contains cycle\")\n            return\n\n        # Print topological order\n        print(\"Topological Sort:\", top_order)\n</code></pre>"},{"location":"dsa/graph/topological-sort/#applications","title":"Applications","text":"<ul> <li>Finding dependent nodes</li> <li>Finding a cycle</li> </ul>"},{"location":"dsa/graph/word-ladder/","title":"Word ladder","text":""},{"location":"dsa/graph/word-ladder/#word-ladder-1","title":"Word ladder 1","text":"<p>Finding the shortest number of steps to reach end word from begin word</p> <p>Here we simply start doing a BFS from begin word, and since at a time only one letter can differ we find all possible values and append it to the queue  <pre><code>def ladderLength(beginWord, endWord, wordList):\n    wordSet = {word: False for word in wordList}\n    if endWord not in wordSet:\n        return 0\n    queue = [beginWord]\n    changes = 1\n    while len(queue) &gt; 0:\n        size = len(queue)\n        for _ in range(size):\n            word = queue.pop(0)\n            if word == endWord:\n                return changes\n            for i in range(len(word)):\n                for j in range(0, 26):\n                    newWord = word[:i] + chr(ord('a') + j) + word[i + 1:]\n                    if newWord in wordSet and not wordSet[newWord]:\n                        queue.append(newWord)\n                        wordSet[newWord] = True\n        changes += 1\n    return 0\n</code></pre></p>"},{"location":"dsa/graph/word-ladder/#word-ladder-2","title":"Word Ladder 2","text":"<p>Find all possible shortest paths, to reach end word from begin word</p> <p>This solution gives TLE</p> <p>Basically we do a BFS and keep a track of paths</p> <pre><code>def findLadders(beginWord, endWord, wordList):\n    wordMap = {beginWord: [[beginWord]]}\n    wordSet = {word: False for word in wordList}\n    queue = [beginWord]\n    queueSet = {}\n    wordSet[beginWord] = True\n    res = []\n    while len(queue) &gt; 0:\n        size = len(queue)\n        newMap = {}\n        for i in range(size):\n            word = queue.pop(0)\n            if word == endWord:\n                res = wordMap[word]\n                continue\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrtsuvwxyz':\n                    newWord = word[:i] + c + word[i + 1:]\n                    if newWord in wordSet and not wordSet[newWord]:\n                        if newWord not in newMap:\n                            newMap[newWord] = [path + [newWord] for path in wordMap[word]]\n                        else:\n                            newMap[newWord] += ([path + [newWord] for path in wordMap[word]])\n                        if newWord not in queueSet:\n                            queue.append(newWord)\n                            queueSet[newWord] = True\n        for word in queue:\n            wordSet[word] = True\n        queueSet = {}\n        wordMap = newMap\n    return res\n</code></pre>"},{"location":"dsa/trees/","title":"Trees","text":"<p>Tree Data Structure \ud83c\udf84# Trees</p>"},{"location":"dsa/trees/#traversal","title":"Traversal","text":"Topics Status Introduction to trees #note\ud83d\udcc3 trees/binary-tree-representation \u2705 trees/preorder-traversal #done\u2705 trees/postorder-traversal #done\u2705 trees/inorder-traversal #done\u2705 trees/level-order-traversal #done\u2705 trees/postorder-preorder-inorder-traversal-in-one-traversal #done\u2705"},{"location":"dsa/trees/#medium-problems","title":"Medium Problems","text":"Topics Status trees/height-and-diameter-of-a-binary-tree #done\u2705 trees/maximum-path-sum #done\u2705 trees/check-if-two-trees-are-identical #done\u2705 trees/views-of-binary-tree #done\u2705 trees/symmetric-binary-tree #done\u2705"},{"location":"dsa/trees/#hard-problems","title":"Hard Problems","text":"Topics Status trees/root-to-node-path-in-binary-tree #done\u2705 trees/lca-in-binary-tree #done\u2705 trees/maximum-width-of-a-binary-tree #done\u2705 trees/check-for-children-sum-property #done\u2705 trees/print-all-nodes-at-a-distance-of-k #done\u2705 trees/minimum-time-taken-to-burn-the-binary-tree #done\u2705 trees/count-total-nodes-in-a-complete-binary-tree #done\u2705 trees/construct-binary-tree-from-traversals #done\u2705 trees/serialize-and-deserialize-binary-tree #done\u2705 trees/morris-traversal #done\u2705 trees/flatten-binary-tree-to-linked-list #done\u2705"},{"location":"dsa/trees/#binary-search-trees","title":"Binary Search Trees","text":""},{"location":"dsa/trees/#concept","title":"Concept","text":"Topic Status Introduction to Binary Search Trees #note\ud83d\udcc3 trees/search-in-a-binary-search-tree #done\u2705 trees/find-min-and-max-in-a-bst #done\u2705"},{"location":"dsa/trees/#problems","title":"Problems","text":"Topic Status trees/ceil-and-floor-in-a-bst #done\u2705 trees/insertion-and-deletion-in-a-bst #done\u2705 trees/find-k-smallest-and-largest-element-in-a-bst #done\u2705 trees/check-if-a-tree-is-bst-or-bt #done\u2705 trees/lca-in-a-binary-search-tree #done\u2705 trees/construct-bst-from-preorder-traversal #done\u2705 trees/inorder-successor-and-predecessor-in-bst #done\u2705 trees/merge-2-bst #done\u2705 trees/two-sum-in-a-bst #done\u2705 trees/recover-bst-with-two-nodes-swapper #done\u2705 trees/largest-bst-in-a-bt #done\u2705"},{"location":"dsa/trees/binary-tree-representation/","title":"Binary tree representation","text":"<p>A Tree which has only two child nodes</p> <pre><code>class Node():\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.right = right\n        self.left = left\n</code></pre>"},{"location":"dsa/trees/ceil-and-floor-in-a-bst/","title":"Ceil and floor in a bst","text":""},{"location":"dsa/trees/ceil-and-floor-in-a-bst/#ceil","title":"Ceil","text":"<p>Ceil of a number \\(x\\) is the immediate greater number than \\(x\\) <pre><code>def findCeil(self,root, x):\n    ans = -1\n    def helper(root):\n        nonlocal ans\n        if root is None:\n            return\n            if x &gt; root.val:\n                helper(root.right)\n            elif x &lt; root.val:\n                ans = root.val\n                helper(root.left)\n            else:\n                ans = root.val\n    helper(root)\n    return ans\n</code></pre> Note: Iterative and Recursive approach to this solution is same</p>"},{"location":"dsa/trees/ceil-and-floor-in-a-bst/#floor","title":"Floor","text":"<p>Floor of a number \\(x\\) is the immediate smaller number than \\(x\\) <pre><code>def findFloor(self,root, x):\n    ans = -1\n    def helper(root):\n        nonlocal ans\n        if root is None:\n            return\n        if x &gt; root.val:\n            ans = root.val\n            helper(root.right)\n        elif x &lt; root.val:\n            helper(root.left)\n        else:\n            ans = root.val\n    helper(root)\n    return ans\n</code></pre> Note: Iterative and Recursive approach to this solution is same</p>"},{"location":"dsa/trees/check-for-children-sum-property/","title":"Check for children sum property","text":"<p>Modify a binary tree so that each node follow children sum property, where children sum property is  $$ \\text{sum of right subtree + sum of left subtree = value of root} $$ <pre><code>def child_sum(root):\n    if root is None:\n        return\n\n    childsum=0\n\n    if root.left:\n        childsum = childsum + root.left.val\n    if root.right:\n        childsum = childsum + root.right.val\n\n    if childsum &lt; root.val:\n        if root.left:\n            root.left.val = childsum\n        elif root.right:\n            root.right.val = childsum\n\n    child_sum(root.left)\n    child_sum(root.right)\n\n    total=0\n    if root.left:\n        total = total + root.left.val\n    if root.right:\n        total = total + root.right.val\n    if root.left or root.right:\n        root.val = total\n</code></pre></p> <ul> <li>If sum of right and left subtree is greater than root's value we can simply set root's value as sum of left and right subtree</li> <li>else, if not copy the value to left or right subtree, this will ensure sum of children is greater than the node</li> </ul>"},{"location":"dsa/trees/check-if-a-tree-is-bst-or-bt/","title":"Check if a tree is bst or bt","text":"<p> <pre><code>def isValidBST(root):\n    mn = -10000000000\n    mx = 10000000000\n    def isPossible(root, minimum, maximum):\n        if root is None:\n            return True\n        if minimum &lt; root.val and root.val &lt; maximum:\n            return isPossible(root.left, minimum, root.val) and isPossible(root.right, root.val, maximum)\n        else:\n            return False\n    return isPossible(root, mn, mx)\n</code></pre></p>"},{"location":"dsa/trees/check-if-two-trees-are-identical/","title":"Check if two trees are identical","text":"<p>Two trees are identical when corresponding values of node are equal</p> <pre><code>def is_identical(root1, root2):\n    if root1 is None and root2 is None:\n        return True\n    if root1 is None or root2 is None:\n        return False\n    return is_identical(root1.left, root2.left) and is_identical(root1.right, root2.right) and root1.val == root2.val\n</code></pre>"},{"location":"dsa/trees/construct-binary-tree-from-traversals/","title":"Construct binary tree from traversals","text":""},{"location":"dsa/trees/construct-binary-tree-from-traversals/#construct-a-binary-tree-from-inorder-and-preorder-traversal","title":"Construct a binary tree from Inorder and Preorder Traversal","text":"<pre><code>def create_tree(inorder, preorder):\n    indexOf = {}\n    for i, val in enumerate(inorder):\n        indexOf[val] = i\n    def helper(istart, iend, pstart, pend):\n        if istart &gt; iend or pstart &gt; pend:\n            return None\n        root = Node(preorder[pstart])\n\n        rootIndex = indexOf[root.val]\n        leftElements = rootIndex - istart\n        root.left = helper(istart, rootIndex - 1, pstart + 1, pstart + leftElements)\n        root.right = helper(rootIndex + 1, iend, pstart + leftElements + 1, pend)\n        return root\n    newRoot = helper(0, len(inorder) - 1, 0, len(preorder) - 1)\n    return newRoot\n</code></pre>"},{"location":"dsa/trees/construct-binary-tree-from-traversals/#construct-a-binary-tree-from-inorder-and-postorder-traversal","title":"Construct a binary tree from Inorder and Postorder Traversal","text":"<pre><code>def create_tree(inorder, postorder):\n    indexOf = {}\n    for i, val in enumerate(inorder):\n        indexOf[val] = i\n    def helper(istart, iend, pstart, pend):\n        if istart &gt; iend or pstart &gt; pend:\n            return None\n        root = Node(postorder[pend])\n\n        rootIndex = indexOf[root.val]\n        leftElements = rootIndex - istart\n        root.left = helper(istart, istart + leftElements, pstart, pstart + leftElements - 1)\n        root.right = helper(rootIndex + 1, iend, pstart + leftElements, pend - 1)\n        return root\n    newRoot = helper(0, len(inorder) - 1, 0, len(postorder) - 1)\n    return newRoot\n</code></pre>"},{"location":"dsa/trees/construct-bst-from-preorder-traversal/","title":"Construct bst from preorder traversal","text":"<p>We are given a preorder array of a BST, and we have to create a BST. To solve this we have three solutions</p>"},{"location":"dsa/trees/construct-bst-from-preorder-traversal/#on2-solution","title":"\\(O(n^2)\\) Solution","text":"<p>We take the 0th index of the preorder as the root, then find index of the number, just greater than root, let say \\(i\\) , now all elements below \\(i\\), will go in the left, while rest will go in the right subtree. Since we are searching for the element every time, this method's complexity is \\(O(n^2)\\).</p> <pre><code>def bstFromPreorder(self, preorder):\n    if len(preorder) == 0:\n        return None\n    root = TreeNode(preorder.pop(0))\n    index = len(preorder)\n    for i in range(len(preorder)):\n        if preorder[i] &gt; root.val:\n            index = i\n            break\n    root.left = self.bstFromPreorder(preorder[:index])\n    root.right = self.bstFromPreorder(preorder[index:])\n    return root\n</code></pre>"},{"location":"dsa/trees/construct-bst-from-preorder-traversal/#onlogn-solution","title":"\\(O(nlogn)\\) Solution","text":"<p>Instead of searching linearly we can use upper bound and lower bound function to find the element in \\(log(n)\\). <pre><code>def bstFromPreorder(self):\n    if len(preorder) == 0:\n        return None\n    root = TreeNode(preorder.pop(0))\n    index = bisect.bisect(preorder, root.val)\n    root.left = self.bstFromPreorder(preorder[:index])\n    root.right = self.bstFromPreorder(preorder[index:])\n    return root\n</code></pre></p>"},{"location":"dsa/trees/construct-bst-from-preorder-traversal/#on-solution","title":"\\(O(n)\\) Solution","text":"<p>This solution tracks and indexes the preorder <pre><code>def bstFromPreorder(preorder):\n    i = 0\n    def helper(A, bound):\n        nonlocal i\n        if i == len(A) or A[i] &gt; bound:\n            return None\n        root = TreeNode(A[i])\n        i += 1\n        root.left = bstFromPreorder(A, root.val)\n        root.right = bstFromPreorder(A, bound)\n        return root\n    return helper(preorder, 10000000000)\n</code></pre></p>"},{"location":"dsa/trees/count-total-nodes-in-a-complete-binary-tree/","title":"Count total nodes in a complete binary tree","text":"<p>Count total nodes in a complete binary tree, where a complete binary tree is a tree where all  - All levels except the last one are completely filled. The last level may or may not be completely filled. - Nodes in the last level are as left as possible.</p> <p>Properties of a complete binary tree: - left most depth will be the height of the tree - hence, if the right most depth is equal to left most depth then the tree is complete binary, having all nodes and we can find total maximum nodes as \\(2^h + 1\\). - if the right most depth is not equal to left most depth, we can go one step down either left and right and check the same, then total nodes would be \\(\\(\\text{Total nodes = 1 + nodes in left subtree + nodes in right subtree}\\)\\) <pre><code>def countNodes(root):\n        def goLeft(root):\n            if root is None:\n                return 0\n            return 1 + goLeft(root.left)\n        def goRight(root):\n            if root is None:\n                return 0\n            return 1 + goRight(root.right)\n\n        leftHeight = goLeft(root)\n        rightHeight = goRight(root)\n        if leftHeight == rightHeight:\n            return 2 ** leftHeight - 1\n        else:\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n</code></pre></p>"},{"location":"dsa/trees/find-k-smallest-and-largest-element-in-a-bst/","title":"Find k smallest and largest element in a bst","text":"<p>To find k smallest and largest element, we traverse the tree in a Inorder fashion and keep track of the index when traversal backtracks after reaching the leftmost node.</p>"},{"location":"dsa/trees/find-k-smallest-and-largest-element-in-a-bst/#finding-k-smallest-element","title":"Finding K smallest element","text":"<pre><code>def kthSmallest(root, k)\n    ans = 0\n    index = 0\n    def helper(root):\n        nonlocal ans, index\n        if root is None:\n            return\n        helper(root.left)\n        index = index + 1\n        if index == k:\n            ans = root.val\n            return\n        helper(root.right)\n    helper(root)\n    return ans\n</code></pre> <p>Finding K largest element <pre><code>def kthLargest(root, k)\n    ans = 0\n    index = 0\n    def helper(root):\n        nonlocal ans, index\n        if root is None:\n            return\n        helper(root.right)\n        index = index + 1\n        if index == k:\n            ans = root.val\n            return\n        helper(root.left)\n    helper(root)\n    return ans\n</code></pre></p>"},{"location":"dsa/trees/find-min-and-max-in-a-bst/","title":"Find min and max in a bst","text":"<p>To find minimum and maximum in a BST, if can follow the properties of BST. In a BST, left subtree's value is less then root node, and right subtree's value is greater than root node.</p> <p>Hence,  - Going to left most node will give us the minimum node - Going to right most node will give us the maximum node</p>"},{"location":"dsa/trees/flatten-binary-tree-to-linked-list/","title":"Flatten binary tree to linked list","text":"<p> <pre><code>def flatten(self, root):\n        curr = root\n        while curr:\n            if curr.left is None:\n                curr = curr.right\n            else:\n                pre = curr.left\n                while pre.right:\n                    pre = pre.right\n                # Link pre to curr right\n                pre.right = curr.right\n                # Swap child nodes\n                curr.right = curr.left\n                curr.left = None\n                # Go right\n                curr = curr.right\n</code></pre></p>"},{"location":"dsa/trees/height-and-diameter-of-a-binary-tree/","title":"Height and diameter of a binary tree","text":""},{"location":"dsa/trees/height-and-diameter-of-a-binary-tree/#height","title":"Height","text":"<p>Height of a binary tree is ==count of longest path== from the root node</p> <pre><code>def height(root):\n    def helper(node, height):\n        if node is None:\n            return height\n        left = 0\n        right = 0\n        if node.left is not None:\n            left = helper(node.left, height + 1)\n        if node.right is not None:\n            right = helper(node.right, height + 1)\n        return max(left, right) + 1\n    return helper(root, 0)\n</code></pre>"},{"location":"dsa/trees/height-and-diameter-of-a-binary-tree/#diameter","title":"Diameter","text":"<p>Diameter of a binary tree is count of the ==longest path between any two nodes== in a binary tree</p> <pre><code>def diameter(root):\n    diameter = 0\n    def helper(node, height):\n        if node is None:\n            return height\n        left = 0\n        right = 0\n        if node.left is not None:\n            left = helper(node.left, height + 1)\n        if node.right is not None:\n            right = helper(node.right, height + 1)\n        nonlocal diameter\n        diameter = max(diameter, left + right)\n        return max(left, right) + 1\n    helper(root, 0)\n    return diameter\n</code></pre> <p>Here for calculating diameter we consider each node as the curving point, and the node with maximum sum of height of left and right subtrees would be the longest path.  </p>"},{"location":"dsa/trees/inorder-successor-and-predecessor-in-bst/","title":"Inorder successor and predecessor in bst","text":"<pre><code>def\u00a0predecessorSuccessor(root,\u00a0key):\n    prev = -1\n    succ = -1\n    def\u00a0helper(node):\n        nonlocal\u00a0prev,nex\n        if\u00a0node\u00a0is\u00a0None:\n            return\n        if\u00a0key &lt; node.data:\n            succ = node.data\n            helper(node.left)\n        elif\u00a0key &gt; node.data:\n            prev = node.data\n            helper(node.right)\n        else:\n            helper(node.left)\n            helper(node.right)\n    helper(root)\n    return\u00a0[prev, succ]\n</code></pre>"},{"location":"dsa/trees/inorder-traversal/","title":"Inorder traversal","text":""},{"location":"dsa/trees/inorder-traversal/#inorder-traversal","title":"Inorder Traversal","text":"<p>Traversal where we access left child, root and then right child node</p> \\[     left\\ child \\rightarrow root \\rightarrow right\\ child \\]"},{"location":"dsa/trees/inorder-traversal/#inorder-traversal-recursive","title":"Inorder Traversal Recursive","text":"<pre><code>def inorder():\n    if node is None:\n        return\n    inorder(node.left)\n    print(node.val)\n    inorder(node.right)\n</code></pre>"},{"location":"dsa/trees/inorder-traversal/#inorder-traversal-iterative","title":"Inorder Traversal Iterative","text":"<pre><code>def inorder():\n    currNode = tree\n    stack = []\n    while currNode is not None or len(stack) != 0:\n        if currNode != None:\n            stack.append(currNode)\n            currNode = currNode.left\n        else:\n            parent = stack.pop()\n            rightNode = parent.right\n            print(parent.val)\n\n            if rightNode is None:\n                if len(stack) != 0:\n                    parent = stack.pop()\n                    print(parent.val)\n                    currNode = parent.right\n            else:\n                currNode = rightNode\n</code></pre>"},{"location":"dsa/trees/insertion-and-deletion-in-a-bst/","title":"Insertion and deletion in a bst","text":""},{"location":"dsa/trees/insertion-and-deletion-in-a-bst/#insertion","title":"Insertion","text":"<p>Inserting in a BST is straight forward <pre><code>def insertIntoBST(root, val):\n    if root is None:\n        return TreeNode(val)\n    if val &lt; root.val:\n        root.left = self.insertIntoBST(root.left, val)\n    else:\n        root.right = self.insertIntoBST(root.right, val)\n    return root\n</code></pre></p>"},{"location":"dsa/trees/insertion-and-deletion-in-a-bst/#deletion","title":"Deletion","text":"<p>In deletion to reduce complexity, we exchange the node to be deleted with it's Inorder predecessor, and remove the predecessor, this make it easy since predecessor is usually a leaf node. <pre><code>def helper(root, key):\n    if root is not None:\n        if root.val == key:\n            if root.left and root.right:\n                pre = root.left\n                    while pre.right:\n                        pre = pre.right\n                    # Assign predecessor as root \n                    root.val = pre.val\n                    # Delete the predecessor\n                    root.left = helper(root.left, pre.val)\n            elif root.left or root.right:\n                return root.left if root.left else root.right\n            else:\n                return None\n        elif key &lt; root.val:\n            root.left = helper(root.left, key)\n        else:\n            root.right = helper(root.right, key)\n    return root\n</code></pre></p>"},{"location":"dsa/trees/introduction-to-binary-search-trees/","title":"Introduction to binary search trees","text":"<p>Binary Search Tree are binary trees which follows the following property \\(\\(\\text{value of left node &lt; value of root &lt; value of right node}\\)\\)</p>"},{"location":"dsa/trees/introduction-to-trees/","title":"Introduction to trees","text":"<p>Important theory and notes related to trees</p> <pre><code>class Node():\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.right = right\n        self.left = left\n</code></pre>"},{"location":"dsa/trees/largest-bst-in-a-bt/","title":"Largest bst in a bt","text":"<p>We need to find largest BST in a binary tree. For that we need to tell that at a current node both ==left and right subtree is a binary tree or not== and the ==current node is also a valid node==.</p> <ul> <li>To do that we follow bottom up approach and maintain the minimum value found and the maximum value found while traversing up the tree.</li> <li>To find if the current node is a valid BST node or not, we see if the maximum value of subtree is smaller than current node and minimum value of right subtree is greater than the current node</li> </ul> <pre><code>def largestBst(self, root):\n        maxAns = 0\n        # returned values are [maxSize, minimum, maximum]\n        def helper(root):\n            if root is None:\n                # this is particulary of a edge\n                # where we need to statisfy the bst condition\n                return (0, 1e10, -1e10)\n            lans, lmini, lmaxi = helper(root.left)\n            rans, rmini, rmaxi = helper(root.right)\n\n            if lmaxi &lt; root.data &lt; rmini:\n                return (lans + rans + 1, min(lmini, root.data), max(rmaxi, root.data))\n\n            return (max(lans, rans), -1e10, 1e10)\n        return helper(root)[0]\n</code></pre>"},{"location":"dsa/trees/lca-in-a-binary-search-tree/","title":"Lca in a binary search tree","text":"<p>If a node let's \\(x\\) is the LCA of \\(p\\) and \\(q\\) then  $$ \\begin{equation} \\text{p.val &lt;= x.val &lt;= q.val} \\end{equation} $$ <pre><code>def lowestCommonAncestor(root, p, q):\n    # Bring the root in range\n    if root.val &lt; p.val and root.val &lt; q.val:\n        return lowestCommonAncestor(root.right, p, q)\n    elif root.val &gt; p.val and root.val &gt; q.val:\n        return lowestCommonAncestor(root.left, p, q)\n    else:\n        # This is LCA\n        return root\n</code></pre></p>"},{"location":"dsa/trees/lca-in-binary-tree/","title":"Lca in binary tree","text":"<p>Finding the lowest common ancestor of two nodes in a binary tree</p> <pre><code>def lca(root, node1, node2):\n    ancestor = None\n    def helper(root):\n        nonlocal ancestor\n        if root is None:\n            return False\n        left = helper(root.left)\n        right = helper(root.right)\n        if left and right:\n            ancestor = root\n            return True\n        if root.val == node1.val or root.val == node2.val: \n            ancestor = root\n            return True\n        return left or right\n    helper(root)\n\n    if ancestor is None:\n        print(\"No Ancestor\")\n    else:\n        print(ancestor.val)\n</code></pre> <ul> <li>The target node could itself  be the ancestor</li> <li>The node which has node1 in left subtree and node2 in right subtree could also be the ancestor</li> </ul>"},{"location":"dsa/trees/level-order-traversal/","title":"Level order traversal","text":"<p>Traversing the tree level by level</p> <pre><code>def levelorder(root):\n    queue = [root]\n    level = 0\n    while len(queue) != 0:\n        print(level, end=\" -&gt; \")\n        level = level + 1\n        queue_size = len(queue)\n        for i in range(0, queue_size):\n            node = queue.pop(0)\n            print(node.val, end=\" \")\n            if node.left is not None:\n                queue.append(node.left)\n            if node.right is not None:\n                queue.append(node.right)\n        print()\n</code></pre>"},{"location":"dsa/trees/maximum-path-sum/","title":"Maximum path sum","text":"<p>Find the sequence of nodes with the maximum sum</p> <pre><code>def maximum_path_sum(root):\n    maxSum = -100000\n    def helper(root):\n        if root is None:\n            return 0\n        left = 0\n        right = 0\n        if root.left is not None:\n            left = max(left, helper(root.left))\n        if root.right is not None:\n            right = max(right, helper(root.right))\n        nonlocal maxSum\n        maxSum = max(maxSum, left + right + root.val)\n        return max(left, right) + root.val\n    helper(root)\n    return maxSum\n</code></pre> <p>Similar to diameter problem on every node we calculate the max sum as: $$ max(maxSum,\\ maxSum\\ of\\ left\\ subtree\\ +\\ maxSum\\ of\\ right\\ subtree\\ +\\ value\\ of\\ root) $$</p>"},{"location":"dsa/trees/maximum-width-of-a-binary-tree/","title":"Maximum width of a binary tree","text":"<p>Find the maximum width of the binary tree, where width is the no. of nodes (null or non-null) between leftmost and rightmost node of a particular level</p> <pre><code>def maxWidth(node):\n    width = 0\n    queue = [(node, 0)]\n    while len(queue) != 0:\n        left_most = 0\n        right_most = 0\n        size = len(queue)\n        print(queue)\n        for i in range(0, size):\n            temp, curr_index = queue[0]\n            queue.pop(0)\n            if i == 0:\n                left_most = curr_index\n            if i == size - 1:\n                right_most = curr_index\n            if temp.left is not None:\n                queue.append((temp.left, curr_index * 2 + 1))\n            if temp.right is not None:\n                queue.append((temp.right , curr_index * 2 + 2))\n        width = max(width, right_most - left_most + 1)\n    print(width)\n</code></pre>"},{"location":"dsa/trees/merge-2-bst/","title":"Merge 2 bst","text":"<p>We are given 2 BSTs, we need to merge them to create a new one, this is quite simple</p> <p>Approach: - Create a Inorder array/Linked list for both BSTs - Merge the Inorder array/Linked list - Recreate a BST from Inorder array/Linked list</p>"},{"location":"dsa/trees/minimum-time-taken-to-burn-the-binary-tree/","title":"Minimum time taken to burn the binary tree","text":"<p>Variant of print at K</p>"},{"location":"dsa/trees/morris-traversal/","title":"Morris traversal","text":"<p>Morris Traversal is a way to traverse a tree without the need of a stack or recursion. In Morris Traversal no recursion is necessary, because instead of relying on backtracking through a stack, a link back to the root of the (sub)tree is moved to the point at which it would be accessed in a recursive Inorder tree traversal algorithm anyway -- after its left subtree has finished. Steps in Morris Inorder: - current is root, if there is a node left of current, ==find the rightmost node== in the left subtree of current and link it to the current node, we call this a ==backlink==. Now, move current node to left subtree - Now, we continue, the first step, and go left - if left is None, or there is no left subtree, we go right, now here right could be a backlink or a regular link down the node - now if we rode a backlink, we would go back to the parent of the subtree, and follow step one, now since there is a backlink, finding the rightmost node of the subtree, will loop back to current. In which case we remove the backlink, and go further right</p>"},{"location":"dsa/trees/morris-traversal/#morris-inorder","title":"Morris Inorder","text":"<pre><code>def morris_inorder(root):\n    curr = root\n    while curr:\n        if curr.left is None:\n            print(curr.val, end = \" \")\n            curr = curr.right\n        else:\n            right_most = curr.left\n            while right_most.right and right_most.right != curr:\n                right_most = right_most.right\n\n            if right_most.right is None:\n                right_most.right = curr\n                curr = curr.left\n            else:\n                right_most.right = None\n                print(curr.val, end = \" \")\n                curr  = curr.right\n</code></pre>"},{"location":"dsa/trees/morris-traversal/#morris-preorder","title":"Morris Preorder","text":"<pre><code>def morris_preorder(root):\n    curr = root\n    while curr:\n        if curr.left is None:\n            print(curr.val, end = \" \")\n            curr = curr.right\n        else:\n            right_most = curr.left\n            while right_most.right and right_most.right != curr:\n                right_most = right_most.right\n\n            if right_most.right is None:\n                right_most.right = curr\n                print(curr.val, end = \" \")\n                curr = curr.left\n            else:\n                right_most.right = None\n                curr  = curr.right\n</code></pre>"},{"location":"dsa/trees/morris-traversal/#morris-postorder","title":"Morris Postorder","text":"<p>Morris post order is the mirror image of preorder <pre><code>def morris_postorder(root):\n    curr = root\n    postorder = []\n    while curr:\n        if curr.right is None:\n            postorder.append(curr.val)\n            curr = curr.left\n        else:\n            right_most = curr.right\n            while right_most.left and right_most.left != curr:\n                right_most = right_most.left\n\n            if right_most.left is None:\n                right_most.left = curr\n                postorder.append(curr.val)\n                curr = curr.right\n            else:\n                right_most.left = None\n                curr  = curr.left\n    print(\" \".join(map(str, postorder[::-1])))\n</code></pre></p>"},{"location":"dsa/trees/postorder-preorder-inorder-traversal-in-one-traversal/","title":"Postorder preorder inorder traversal in one traversal","text":"<p>This solution is based on the fact that in - preorder traversal we print the node when we visit the node 1st time - inorder traversal we print the node when we visit the node 2nd time - postorder traversal we print the node when we visit the node 3rd time</p> <pre><code>def single_traversal(root):\n    preorder = []\n    postorder = []\n    inorder = []\n    stack = [[root, 1]]\n    while len(stack) != 0:\n        node, count = stack.pop()\n        if count == 1:\n            preorder.append(node.val)\n            stack.append([node, count + 1])\n            if node.left is not None:\n                stack.append([node.left, 1])\n        elif count == 2:\n            inorder.append(node.val)\n            stack.append([node, count + 1])\n            if node.right is not None:\n                stack.append([node.right, 1])\n        else:\n            postorder.append(node.val)\n    print(preorder)\n    print(postorder)\n    print(inorder)\n</code></pre>"},{"location":"dsa/trees/postorder-traversal/","title":"Postorder traversal","text":""},{"location":"dsa/trees/postorder-traversal/#postorder-traversal","title":"Postorder Traversal","text":"<p>Traversal where we access root node, left child and then right child node</p> \\[ left\\ child \\rightarrow right\\ child  \\rightarrow root \\]"},{"location":"dsa/trees/postorder-traversal/#postorder-traversal-recursive","title":"Postorder Traversal Recursive","text":"<pre><code>def postorder(node):\n    if node is None:\n        return\n    postorder(node.left)\n    postorder(node.right)\n    print(node.val)\n</code></pre>"},{"location":"dsa/trees/postorder-traversal/#postorder-traversal-using-2-stacks","title":"Postorder Traversal using 2 Stacks","text":"<pre><code>def postorder():\n    stack = [tree]\n    _stack = []\n    while len(stack) != 0:\n        node = stack.pop()\n        if node.left is not None:\n            stack.append(node.left)\n        if node.right is not None:\n            stack.append(node.right)\n        _stack.append(node)\n    while len(_stack) != 0:\n        node = _stack.pop()\n        print(node.val)\n</code></pre>"},{"location":"dsa/trees/postorder-traversal/#postorder-traversal-using-1-stack","title":"Postorder Traversal using 1 Stack","text":"<pre><code>def postorder():\n    currNode = tree\n    stack = []\n    while currNode != None or len(stack) != 0:\n        if currNode is not None:\n            stack.append(currNode)\n            currNode = currNode.left\n        else:\n            parent = stack[-1]\n            rightNode = parent.right\n\n            if rightNode is None:\n                rightNode = stack.pop()\n                print(rightNode.val)\n                while len(stack) != 0 and rightNode == stack[-1].right:\n                    rightNode = stack.pop()\n                    print(rightNode.val)\n            else:\n                currNode = rightNode\n</code></pre> <p>Explanation: - Start with current root and go left and push the current node to stack - In case there is no left, change to current node to the immediate parent's right - if there is no right, pop the immediate parent from the stack - now the popped node could be the right child of the new immediate parent (the top element in stack) the means both child of the new immediate parents have been traversed, so pop that too, and loop till it's not the case</p>"},{"location":"dsa/trees/preorder-traversal/","title":"Preorder traversal","text":""},{"location":"dsa/trees/preorder-traversal/#preorder-traversal","title":"Preorder Traversal","text":"<p>Traversal where we access root node, left child and then right child node</p> \\[ root \\rightarrow left\\ child \\rightarrow right\\ child \\]"},{"location":"dsa/trees/preorder-traversal/#preorder-recursive-approach","title":"Preorder Recursive Approach","text":"<pre><code>def preorder(node):\n    if node is None:\n        return\n    print(node.val)\n    preorder(node.left)\n    preorder(node.right)\n</code></pre>"},{"location":"dsa/trees/preorder-traversal/#preorder-iterative-approach","title":"Preorder Iterative Approach","text":"<pre><code>def preorder():\n    stack = [root]\n    while len(stack) != 0:\n        node = stack.pop()\n        print(node.val)\n        if node.right is not None:\n            stack.append(node.right)\n        if node.left is not None:\n            stack.append(node.left)\n</code></pre>"},{"location":"dsa/trees/print-all-nodes-at-a-distance-of-k/","title":"Print all nodes at a distance of k","text":"<pre><code>def print_at_k(root, target, k):\n    parent_map = {}\n\n    # Creating Graph (Adjacent list)\n    def create_map(root):\n        nonlocal parent_map\n        queue = [root]\n        while len(queue) != 0:\n            size = len(queue)\n            for i in range(size):\n                node = queue.pop(0)\n\n                if node not in parent_map:\n                    parent_map[node] = []\n                if node.left not in parent_map and node.left is not None:\n                    parent_map[node.left] = []\n                if node.right not in parent_map and node.right is not None:\n                    parent_map[node.right] = []\n\n                if node.left is not None:\n                    parent_map[node].append(node.left)\n                    parent_map[node.left].append(node)\n                    queue.append(node.left)\n                if node.right is not None:\n                    parent_map[node].append(node.right)\n                    parent_map[node.right].append(node)\n                    queue.append(node.right)\n    create_map(root)\n    for key in parent_map:\n        print(key.val, list(map(lambda x: x.val, parent_map[key])))\n    visited = {}\n    queue = [target]\n    curr_k = 0\n\n    # BFS\n    while len(queue) != 0:\n        if curr_k == k:\n            break\n        curr_k = curr_k + 1\n        size = len(queue)\n        for i in range(size):\n            node = queue.pop(0)\n            visited[node] = True\n            for node in parent_map[node]:\n                if node in visited:\n                    continue\n                queue.append(node)\n    print(list(map(lambda x: x.val, queue)))\n\nprint_at_k(tree, tree.left.left, 2)\n</code></pre> <ul> <li>Basically create a graph out of tree and traverse it breadth first, with each breadth as a level</li> </ul>"},{"location":"dsa/trees/recover-bst-with-two-nodes-swapper/","title":"Recover bst with two nodes swapper","text":"<p>Given a BST with exactly two nodes being swapped by mistake, recover the BST <pre><code>def recoverTree(root):\n    first = None\n    second = None\n    prev = TreeNode(-1e10)\n    def helper(root):\n        nonlocal first, second, prev\n        if root is None:\n            return\n        helper(root.left)\n        if first is None and prev.val &gt; root.val:\n            first = prev\n        if first is not None and prev.val &gt; root.val:\n            second = root\n        prev = root\n        helper(root.right)\n    helper(root)\n    temp = first.val\n    first.val = second.val\n    second.val = temp\n</code></pre></p>"},{"location":"dsa/trees/root-to-node-path-in-binary-tree/","title":"Root to node path in binary tree","text":"<p>Find the path from root to given node</p> <pre><code>def node_path(root, target):\n    path = []\n    def helper(root):\n        nonlocal path\n        if root is None:\n            return False\n        if root.val == target:\n            path.append(root.val)\n            return True\n        left = helper(root.left)\n        right = helper(root.right)\n        if left or right:\n            path.append(root.val)\n            return True\n    helper(root)\n    return path[::-1]\n</code></pre>"},{"location":"dsa/trees/search-in-a-binary-search-tree/","title":"Search in a binary search tree","text":"<pre><code>def searchBST(self, root, val):\n        if root is None:\n            return None\n        if root.val == val:\n            return root\n        if val &lt; root.val:\n            return searchBST(root.left, val)\n        else:\n            return searchBST(root.right, val)\n</code></pre>"},{"location":"dsa/trees/serialize-and-deserialize-binary-tree/","title":"Serialize and deserialize binary tree","text":"<pre><code>def serialize(self, root):\n    ans = \"\"\n    queue = [root]\n    while len(queue) != 0:\n        node = queue.pop(0)\n        if node is not None:\n            ans = ans + str(node.val)\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            ans = ans + \"N\"\n        ans = ans + \" \"\n    return ans\n\ndef deserialize(self, data):\n    data = list(data.split(\" \"))[:-1]\n    if \u00a0data[0] == 'N':\n        return None\n    root = TreeNode(int(data[0]))\n    data.pop(0)\n    queue = [root]\n    while len(data) &gt; 0 and len(queue) &gt; 0:\n        node = queue.pop(0)\n        if data[0] != 'N':\n            node.left = TreeNode(int(data.pop(0)))\n            queue.append(node.left)\n        else:\n            data.pop(0)\n        if \u00a0data[0] != 'N':\n            node.right = TreeNode(int(data.pop(0)))\n            queue.append(node.right)\n        else:\n            data.pop(0)\n    return root\n</code></pre>"},{"location":"dsa/trees/symmetric-binary-tree/","title":"Symmetric binary tree","text":"<p>Find if a binary tree is a mirror image of itself</p> <pre><code>def is_symmetrical(root):\n    def helper(root1, root2):\n        if root1 is None and root2 is None:\n            return True\n        if root1 is None or root2 is None:\n            return False\n        return root1.val == root2.val and helper(root1.left, root2.right) and helper(root1.right, root2.left)\n    return helper(root.left, root.right)\n</code></pre>"},{"location":"dsa/trees/two-sum-in-a-bst/","title":"Two sum in a bst","text":"<p>We have tell if the sum \\(k\\) , is possible by adding two nodes in the BST</p> <p><pre><code>def findTarget(root, k):\n    sumMap = {}\n    ans = False\n    def helper(root):\n        nonlocal sumMap, ans\n        if root is None:\n            return None\n        helper(root.left)\n        if k - root.val in sumMap:\n            ans = True\n            return\n        sumMap[root.val] = True\n        helper(root.right)\n    helper(root)\n    return ans\n</code></pre> Note: Approach is similar to using maps for two sum</p>"},{"location":"dsa/trees/views-of-binary-tree/","title":"Views of binary tree","text":""},{"location":"dsa/trees/views-of-binary-tree/#topbottom-view","title":"Top/Bottom  View","text":"<p>To create top/bottom views we create imaginary numbered ==vertical== lines through nodes, and map top nodes of these lines for top view and bottom nodes for bottom views</p>"},{"location":"dsa/trees/views-of-binary-tree/#top-view","title":"Top View","text":"<pre><code>def top(root):\n    queue = [[root, 0]]\n    lines = {}\n    while len(queue) != 0:\n        node, line = queue.pop(0)\n        if line not in lines:\n            lines[line] = node.val\n        if node.left is not None:\n            queue.append([node.left, line + 1])\n        if node.right is not None:\n            queue.append([node.right, line - 1])\n    print(sorted(list(lines.items()), key=lambda x: x[0]))\n</code></pre>"},{"location":"dsa/trees/views-of-binary-tree/#bottom-view","title":"Bottom View","text":"<pre><code>def bottom(root):\n    queue = [[root, 0]]\n    lines = {}\n    while len(queue) != 0:\n        node, line = queue.pop(0)\n        if line not in lines:\n            lines[line] = node.val\n        else:\n            lines[line] = node.val\n        if node.left is not None:\n            queue.append([node.left, line + 1])\n        if node.right is not None:\n            queue.append([node.right, line - 1])\n    print(sorted(list(lines.items()), key=lambda x: x[0]))\n</code></pre>"},{"location":"dsa/trees/views-of-binary-tree/#leftright-views","title":"Left/Right Views","text":"<p>To create left/right views we create imaginary ==horizontal== lines/level through nodes, and map left-most nodes of these values for left view and right-most nodes for right </p>"},{"location":"dsa/trees/views-of-binary-tree/#left-view","title":"Left View","text":"<pre><code>def left(root):\n    left_view = []\n    queue = [root]\n    while len(queue) != 0:\n        level = []\n        queue_size = len(queue)\n        for i in range(0, queue_size):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left is not None:\n                queue.append(node.left)\n            if node.right is not None:\n                queue.append(node.right)\n        left_view.append(level[0])\n    print(left_view)\n</code></pre>"},{"location":"dsa/trees/views-of-binary-tree/#right-view","title":"Right View","text":"<pre><code>def right(root):\n    right_view = []\n    queue = [root]\n    while len(queue) != 0:\n        level = []\n        queue_size = len(queue)\n        for i in range(0, queue_size):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left is not None:\n                queue.append(node.left)\n            if node.right is not None:\n                queue.append(node.right)\n        right_view.append(level[-1])\n    print(right_view)\n</code></pre>"}]}